<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>C++11 新特性 | wch的博客</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="blog">
    
    <link rel="preload" href="/assets/css/0.styles.e8e4f3a3.css" as="style"><link rel="preload" href="/assets/js/app.65f59352.js" as="script"><link rel="preload" href="/assets/js/2.b450a5ed.js" as="script"><link rel="preload" href="/assets/js/10.fd54be86.js" as="script"><link rel="prefetch" href="/assets/js/11.fa766168.js"><link rel="prefetch" href="/assets/js/3.d527db89.js"><link rel="prefetch" href="/assets/js/4.5b118796.js"><link rel="prefetch" href="/assets/js/5.7a47b2bb.js"><link rel="prefetch" href="/assets/js/6.2059c81a.js"><link rel="prefetch" href="/assets/js/7.1d469f45.js"><link rel="prefetch" href="/assets/js/8.1944fe82.js"><link rel="prefetch" href="/assets/js/9.f683714a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e8e4f3a3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">wch的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/" class="nav-link">
  课程
</a></div><div class="nav-item"><a href="/python/" class="nav-link">
  Python
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">C++</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">C++</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/cpp/effective/" class="nav-link">
  Efficient C++
</a></li><li class="dropdown-item"><!----> <a href="/cpp/modern/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  C++ 11/14
</a></li></ul></div></div><div class="nav-item"><a href="/js/" class="nav-link">
  Javascript
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/" class="nav-link">
  课程
</a></div><div class="nav-item"><a href="/python/" class="nav-link">
  Python
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">C++</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">C++</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/cpp/effective/" class="nav-link">
  Efficient C++
</a></li><li class="dropdown-item"><!----> <a href="/cpp/modern/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  C++ 11/14
</a></li></ul></div></div><div class="nav-item"><a href="/js/" class="nav-link">
  Javascript
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>C++11 新特性</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/cpp/modern/#_1-稳定性与兼容性" class="sidebar-link">1.稳定性与兼容性</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cpp/modern/#_1-1-兼容-c99" class="sidebar-link">1.1 兼容 C99</a></li><li class="sidebar-sub-header"><a href="/cpp/modern/#_1-2-长整型" class="sidebar-link">1.2. 长整型</a></li><li class="sidebar-sub-header"><a href="/cpp/modern/#_1-3-版本宏" class="sidebar-link">1.3. 版本宏</a></li><li class="sidebar-sub-header"><a href="/cpp/modern/#_1-4-静态断言" class="sidebar-link">1.4. 静态断言</a></li><li class="sidebar-sub-header"><a href="/cpp/modern/#_1-5-noexcept-修饰符" class="sidebar-link">1.5. noexcept 修饰符</a></li><li class="sidebar-sub-header"><a href="/cpp/modern/#_1-6-变量初始化" class="sidebar-link">1.6. 变量初始化</a></li><li class="sidebar-sub-header"><a href="/cpp/modern/#_1-7-非静态成员的-sizeof" class="sidebar-link">1.7. 非静态成员的 sizeof</a></li><li class="sidebar-sub-header"><a href="/cpp/modern/#_1-8-friend-语法" class="sidebar-link">1.8. friend 语法</a></li><li class="sidebar-sub-header"><a href="/cpp/modern/#_1-9-final-override" class="sidebar-link">1.9. final/override</a></li><li class="sidebar-sub-header"><a href="/cpp/modern/#_1-10-默认模板参数" class="sidebar-link">1.10. 默认模板参数</a></li><li class="sidebar-sub-header"><a href="/cpp/modern/#_1-11-外部模板" class="sidebar-link">1.11. 外部模板</a></li><li class="sidebar-sub-header"><a href="/cpp/modern/#_1-12-局部和匿名类作模板实参" class="sidebar-link">1.12. 局部和匿名类作模板实参</a></li></ul></li><li><a href="/cpp/modern/#_2-新特性" class="sidebar-link">2. 新特性</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cpp/modern/#_2-1-构造函数" class="sidebar-link">2.1. 构造函数</a></li><li class="sidebar-sub-header"><a href="/cpp/modern/#_2-2-右值引用" class="sidebar-link">2.2. 右值引用</a></li><li class="sidebar-sub-header"><a href="/cpp/modern/#_2-3-显式转换操作符" class="sidebar-link">2.3. 显式转换操作符</a></li><li class="sidebar-sub-header"><a href="/cpp/modern/#_2-4-列表初始化" class="sidebar-link">2.4. 列表初始化</a></li><li class="sidebar-sub-header"><a href="/cpp/modern/#_2-5-pod-类型" class="sidebar-link">2.5. POD 类型</a></li><li class="sidebar-sub-header"><a href="/cpp/modern/#_2-6-sfinea" class="sidebar-link">2.6 SFINEA</a></li><li class="sidebar-sub-header"><a href="/cpp/modern/#_2-7-decltype" class="sidebar-link">2.7 decltype</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="c-11-新特性"><a href="#c-11-新特性" class="header-anchor">#</a> C++11 新特性</h1> <h2 id="_1-稳定性与兼容性"><a href="#_1-稳定性与兼容性" class="header-anchor">#</a> 1.稳定性与兼容性</h2> <h3 id="_1-1-兼容-c99"><a href="#_1-1-兼容-c99" class="header-anchor">#</a> 1.1 兼容 C99</h3> <p>C++11 增加了对 C99 特性的支持。</p> <ul><li>预定义宏</li> <li><code>__func__</code> 预定义标识符</li> <li><code>_Pragma</code> 操作符</li> <li>不定参数宏</li> <li>宽窄字符串连接</li></ul> <h4 id="预定义宏"><a href="#预定义宏" class="header-anchor">#</a> 预定义宏</h4> <p>用于检验机器环境对 C 标准和 C 库的支持状况。预定义宏对多平台代码的编写非常重要，通过 <code>#ifdef</code> 等预处理指令，可以适配不同平台。</p> <ul><li><p><code>__STDC_HOSTED__</code> 编译器的环境是否包含完整的标准 C 库</p></li> <li><p><code>__STDC__</code> 编译器的实现是否和 C 标准一致</p></li> <li><p><code>__STDC_VERSION__</code> C 标准版本</p></li></ul> <p>如果用户重定义预定义宏，结果是ub。</p> <h4 id="func"><a href="#func" class="header-anchor">#</a> <code>__func__</code></h4> <p>返回所在函数的名字。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">/// 打印 hello,world</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token constant">__func__</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">world</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token constant">__func__</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  cout <span class="token operator">&lt;&lt;</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;, &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token function">world</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>甚至可在构造函数初始化中，使用 <code>__func__</code> 初始化成员列表。</p> <h4 id="pragma"><a href="#pragma" class="header-anchor">#</a> <code>_Pragma</code></h4> <p><code>#pragma once</code> 会指示编译器该头文件只编译一次，这与 <code>_Pragma(&quot;once&quot;)</code> 效果一样。</p> <p><code>_Pragma</code> 操作符的格式如下：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token function">_Pragma</span> <span class="token punctuation">(</span>字符字面量<span class="token punctuation">)</span>
</code></pre></div><p><code>_Pragma</code> 是一个操作符，故可嵌套在宏里面。</p> <h4 id="va-args"><a href="#va-args" class="header-anchor">#</a> <code>__VA_ARGS__</code></h4> <p>变长参数的宏定义是指宏定义中参数列表最后一个为省略号，而 <code>__VA_ARGS__</code> 可以替换省略号代表的字符串。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PR</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span>__VA_ARGS__<span class="token punctuation">)</span></span></span>
</code></pre></div><h3 id="_1-2-长整型"><a href="#_1-2-长整型" class="header-anchor">#</a> 1.2. 长整型</h3> <p>在 C++11 中，标准要求 <code>long long</code> 整形可以在不同平台上有不同的长度，但至少有 64 位。在书写数字面量时，可以使用 LL 后缀(或 ll) 标识一个 <code>long long</code> 类型的字面量，使用 ULL 表示一个 <code>unsigned long long</code> 类型字面量。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span> lli <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">9000000000LL</span><span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span> ulli <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">9000000000000000LL</span><span class="token punctuation">;</span>
</code></pre></div><p>C++11 有很多与 <code>long long</code> 等价的类型。下面的类型是等价的：<code>long long</code>, <code>signed long long</code>, <code>long long int</code>.</p> <p>对于 <code>printf</code> 函数，使用 <code>%lld</code> 打印 <code>long long</code> 类型变量。</p> <p>在 <code>&lt;climits&gt;</code> 中有 <code>LLONG_MIN</code>, <code>LLONG_MAX</code> 表示平台上 <code>long long</code> 的最小值和最大值。</p> <h3 id="_1-3-版本宏"><a href="#_1-3-版本宏" class="header-anchor">#</a> 1.3. 版本宏</h3> <p><code>__cplusplus</code> 宏通常被定义为一个整数，随着C++标准变化，该值也会变化，且比以往的值大。</p> <p>在 C++03 中，<code>__cplusplus</code> 为 <code>199711L</code>；在 C++11 标准中，该值为 <code>201103L</code>。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">__cplusplus <span class="token operator">&lt;</span> <span class="token number">201103L</span></span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">error</span> <span class="token string">&quot;should use C++11 implementation&quot;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre></div><p>如果不支持 C++11 则会立即报错并终止。</p> <h3 id="_1-4-静态断言"><a href="#_1-4-静态断言" class="header-anchor">#</a> 1.4. 静态断言</h3> <p>在 C++ 中，<code>&lt;cassert&gt;</code> 头文件定义了 <code>assert</code> 宏，用于运行时断言。可以定义宏 <code>NDEBUG</code> 来禁用 <code>assert</code> 宏，此时 <code>assert</code> 宏会被展开一条无意义的语句。</p> <p>C++11 引入 <code>static_assert</code> ，用于编译器断言，它接受两个参数，一个断言表达式，一个警告信息。</p> <p>断言表达式必须是在编译器可以计算的表达式，即常量表达式。</p> <h3 id="_1-5-noexcept-修饰符"><a href="#_1-5-noexcept-修饰符" class="header-anchor">#</a> 1.5. <code>noexcept</code> 修饰符</h3> <p><code>noexcept</code> 表示其修饰的函数不会抛出异常。如果抛出异常，编译器可以选择直接调用 <code>std::terminate()</code> 来终止程序运行。</p> <p><code>noexcept</code> 语法如下。常量表达式会转换为 bool 类型的值。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">excpt_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">excpt_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">(</span>常量表达式<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>noexcept</code> 可以保证应用程序的安全，比如一个析构函数不应该抛出异常。C++11 析构函数默认 <code>noexcept(true)</code>.</p> <h3 id="_1-6-变量初始化"><a href="#_1-6-变量初始化" class="header-anchor">#</a> 1.6. 变量初始化</h3> <p>C++ 类中 <strong>静态成员变量</strong> 如果是常量且是整型或者枚举型，可以在类内初始化。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Init</span><span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">const</span> <span class="token keyword">static</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// valid</span>
  <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>              <span class="token comment">// invalid</span>
  <span class="token keyword">static</span> <span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token comment">// invalid</span>
  <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">double</span> e <span class="token operator">=</span> <span class="token number">1.3</span><span class="token punctuation">;</span> <span class="token comment">//invalid</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>C++11 允许使用等号或花括号进行非静态成员变量初始化，称之为就地初始化。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">init</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">double</span> b <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>如果一个类既有就地初始化，也有成员列表初始化，则初始化列表初始化变量的效果要优于就地初始化。</p> <h3 id="_1-7-非静态成员的-sizeof"><a href="#_1-7-非静态成员的-sizeof" class="header-anchor">#</a> 1.7. 非静态成员的 sizeof</h3> <p>在 C++98 中，对非静态成员变量使用 <code>sizeof</code> 操作是非法的，而在 C++11 中，是合法的。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>
  <span class="token keyword">int</span> a<span class="token punctuation">;</span>
  <span class="token keyword">static</span> <span class="token keyword">int</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
A a<span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>a<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// C++98 valid, C++11 valid</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>A<span class="token double-colon punctuation">::</span>b<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// C++98 &amp; C++11 valid</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>A<span class="token double-colon punctuation">::</span>a<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// C++98 invalid, C++11 valid</span>
</code></pre></div><p>在 C++98 中，在没有定义类实例时，要获得类成员的大小，需要这样做:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>A<span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="_1-8-friend-语法"><a href="#_1-8-friend-语法" class="header-anchor">#</a> 1.8. friend 语法</h3> <p>C+++11 中，声明一个类为另一个类的友元时，不需要使用 class 关键字。</p> <p>这个改动在模板元编程带来好处：可以为类模板声明友元。</p> <h3 id="_1-9-final-override"><a href="#_1-9-final-override" class="header-anchor">#</a> 1.9. final/override</h3> <p>如果派生类在虚函数声明时使用了 <code>override</code> 描述符，那么该函数必定重载其基类中的同名函数，否则无法通过编译。这既可提示该函数是重载基类函数，也可以保证该函数没有拼写错误，包括函数名拼写错误、函数参数不匹配。</p> <p><code>final</code> 可以阻止派生类重载虚函数。</p> <h3 id="_1-10-默认模板参数"><a href="#_1-10-默认模板参数" class="header-anchor">#</a> 1.10. 默认模板参数</h3> <p>C++11 允许模板声明时有默认参数。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">U</span> <span class="token operator">=</span> <span class="token keyword">double</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T t <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> U u <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token char">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// f&lt;int,char&gt;(1,'c');</span>
  <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// f&lt;int, double&gt;(1,0);</span>
  <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// invalid</span>
  <span class="token generic-function"><span class="token function">f</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// f&lt;int,double&gt;(0,0);</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_1-11-外部模板"><a href="#_1-11-外部模板" class="header-anchor">#</a> 1.11. 外部模板</h3> <h3 id="_1-12-局部和匿名类作模板实参"><a href="#_1-12-局部和匿名类作模板实参" class="header-anchor">#</a> 1.12. 局部和匿名类作模板实参</h3> <p>C++ 11 允许局部类和匿名类作为模板参数</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">X</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">A</span><span class="token punctuation">{</span><span class="token punctuation">}</span> a<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span> B<span class="token punctuation">;</span> <span class="token comment">// B 是匿名类型</span>

<span class="token keyword">void</span> <span class="token function">Fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">C</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> c<span class="token punctuation">;</span>  <span class="token comment">// C 是局部类型</span>
  X<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> x1<span class="token punctuation">;</span>        <span class="token comment">// C++98 &amp; C++11 valid</span>
  X<span class="token operator">&lt;</span>B<span class="token operator">&gt;</span> x2<span class="token punctuation">;</span>        <span class="token comment">// C++98 invalid, C++11 valid</span>
  X<span class="token operator">&lt;</span>C<span class="token operator">&gt;</span> x2<span class="token punctuation">;</span>        <span class="token comment">// C++98 invalid, C++11 valid</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_2-新特性"><a href="#_2-新特性" class="header-anchor">#</a> 2. 新特性</h2> <h3 id="_2-1-构造函数"><a href="#_2-1-构造函数" class="header-anchor">#</a> 2.1. 构造函数</h3> <h4 id="继承构造函数"><a href="#继承构造函数" class="header-anchor">#</a> 继承构造函数</h4> <p>类具有派生性，派生类可以自动获得基类的成员变量和接口(虚函数和纯虚函数)，但是基类的成员函数不能被派生类使用。如果派生类要使用基类的成员函数，可以通过 <code>using</code> 声明来完成。</p> <p>派生类中如果有函数与基类同名，则会<a href="https://gfjiangly.github.io/C++/%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%B8%8E%E5%9F%BA%E7%B1%BB%E7%9A%84%E5%90%8C%E5%90%8D%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%83%85%E5%86%B5.html" target="_blank" rel="noopener noreferrer">屏蔽基类函数<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">Base</span><span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">double</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span><span class="token string">&quot;Base i = &quot;</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">/// 派生类 `Derived` 实际拥有两个 f 函数。</span>
<span class="token keyword">struct</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>f<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span><span class="token string">&quot;Derived i = &quot;</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>C++ 11 中，子类可以通过使用 <code>using 声明</code> 来声明继承基类的构造函数。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">double</span> d<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">float</span> f<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> c<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">B</span><span class="token operator">:</span><span class="token base-clause"><span class="token class-name">A</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">using</span> A<span class="token double-colon punctuation">::</span>A<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里通过 <code>using A::A</code>, 把基类中的构造函数继承到派生类 <code>B</code>.</p> <h4 id="委托构造函数"><a href="#委托构造函数" class="header-anchor">#</a> 委托构造函数</h4> <p>C++ 11 允许将一个构造函数设定为 “基准版本”，其他构造函数可以委派该构造函数来初始化。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Info</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Info</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">InitRest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token function">Info</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token operator">-&gt;</span><span class="token function">Info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> type <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token function">Info</span><span class="token punctuation">(</span><span class="token keyword">char</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token operator">-&gt;</span><span class="token function">Info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> name <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="_2-2-右值引用"><a href="#_2-2-右值引用" class="header-anchor">#</a> 2.2. 右值引用</h3> <h4 id="拷贝构造"><a href="#拷贝构造" class="header-anchor">#</a> 拷贝构造</h4> <p>拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：</p> <ul><li><p>通过使用另一个同类型的对象来初始化新创建的对象。</p></li> <li><p>复制对象把它作为参数传递给函数。</p></li> <li><p>复制对象，并从函数返回这个对象。</p></li></ul> <p>如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。</p> <h4 id="左值、右值与右值引用"><a href="#左值、右值与右值引用" class="header-anchor">#</a> 左值、右值与右值引用</h4> <p>C++ 11 中，右值由将亡值(xvalue) 和纯右值(pvalue). 纯右值是 C++ 98 中右值的概念，如非引用返回的函数返回的临时变量值、运算表达式及不跟对象相关联的字面量，如 2,'c' 等都是纯右值。类型转换函数的返回值、lambda 表达式也是右值。</p> <p>C++ 11 中，右值引用就是对一个右值进行引用的类型。右值引用和左值引用都属于引用类型，都是左值。左值引用是具名变量名的别值，而右值引用是不具名变量的别名。</p> <p><code>T&amp;&amp; b = ReturnRvalue();</code> 比 <code>T b = ReturnRvalue();</code> 会少一次对象的析构和构造(没有 RVO的情况下).</p> <p><code>&lt;utility&gt;</code> 中 <code>std::move()</code> 强制转化为右值引用。继而可以通过右值引用使用该值。</p> <p>被 move 的左值生命周期并没有结束，不会立即析构，但不应再使用该值。</p> <h4 id="完美转发"><a href="#完美转发" class="header-anchor">#</a> 完美转发</h4> <p>完美转发指在函数模板内，完全按照参数的类型，将参数传递给函数模板中调用的另一个函数。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">IamForwoding</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">IrunCodeActually</span><span class="token punctuation">(</span><span class="token function">forward</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="universal-reference"><a href="#universal-reference" class="header-anchor">#</a> Universal Reference</h5> <p>模板参数中 <code>T&amp;&amp;</code> 是一个通用引用。如果传递的是一个左值，那么 T 会推断为左值引用，Param Type 也是左值引用。如果传递的是右值，那么 <code>T</code> 是正常的类型，而 Param Type 为 <code>T&amp;&amp;</code>.</p> <h5 id="引用折叠"><a href="#引用折叠" class="header-anchor">#</a> 引用折叠</h5> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">baz</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  T<span class="token operator">&amp;</span> k <span class="token operator">=</span> t<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> ii <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token generic-function"><span class="token function">baz</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>ii<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这个实例中，T 被显式化为 <code>int&amp;</code>, k 的类型为 <code>int &amp;</code> 因为发生了引用折叠。</p> <p>参考:</p> <ul><li><p><a href="https://www.zhihu.com/question/34544004/answer/59104471" target="_blank" rel="noopener noreferrer">知乎回答：std::move(expr)和std::forward(expr) 疑问<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p><a href="https://eli.thegreenplace.net/2014/perfect-forwarding-and-universal-references-in-c/" target="_blank" rel="noopener noreferrer">Perfect forwarding and universal references in C++<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li></ul> <h3 id="_2-3-显式转换操作符"><a href="#_2-3-显式转换操作符" class="header-anchor">#</a> 2.3. 显式转换操作符</h3> <p><code>explict</code> 禁止隐式转换。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">ConvertTo</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Convertable</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">explicit</span> <span class="token keyword">operator</span> <span class="token function">ConvertTo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">ConvertTo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Convertable c<span class="token punctuation">;</span>
    ConvertTo <span class="token function">ct</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ConvertTo ct2 <span class="token operator">=</span> c<span class="token punctuation">;</span> <span class="token comment">// implicit type conversion, fail</span>
    ConvertTo ct3 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>ConvertTo<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// explicit type conversion, success</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_2-4-列表初始化"><a href="#_2-4-列表初始化" class="header-anchor">#</a> 2.4. 列表初始化</h3> <p>TODO</p> <h3 id="_2-5-pod-类型"><a href="#_2-5-pod-类型" class="header-anchor">#</a> 2.5. POD 类型</h3> <p>POD 是 Plain Old Data 的缩写。</p> <h3 id="_2-6-sfinea"><a href="#_2-6-sfinea" class="header-anchor">#</a> 2.6 SFINEA</h3> <h3 id="_2-7-decltype"><a href="#_2-7-decltype" class="header-anchor">#</a> 2.7 decltype</h3> <p>运行时类型识别(RTTI) 的机制是为每个类型产生一个 <code>type_info</code> 类型的数据。程序员可以在程序中使用 <code>typeid</code> 随时查询一个变量的类型，返回变量相应的 <code>type_info</code> 数据。而 <code>type_info</code> 的 <code>name</code> 成员函数可以返回类型的名字。C++ 11 增加了 <code>hash_code</code> 成员函数，返回该类型唯一的哈希值。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.65f59352.js" defer></script><script src="/assets/js/2.b450a5ed.js" defer></script><script src="/assets/js/10.fd54be86.js" defer></script>
  </body>
</html>
